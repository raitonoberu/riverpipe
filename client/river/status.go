// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : river-status-unstable-v1.xml
//
// river_status_unstable_v1 Protocol Copyright:
//
// Copyright 2020 The River Developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

package river

import "github.com/rajveermalviya/go-wayland/wayland/client"

// StatusManager : manage river status objects
//
// A global factory for objects that receive status information specific
// to river. It could be used to implement, for example, a status bar.
type StatusManager struct {
	client.BaseProxy
}

// NewStatusManager : manage river status objects
//
// A global factory for objects that receive status information specific
// to river. It could be used to implement, for example, a status bar.
func NewStatusManager(ctx *client.Context) *StatusManager {
	zriverStatusManagerV1 := &StatusManager{}
	ctx.Register(zriverStatusManagerV1)
	return zriverStatusManagerV1
}

// Destroy : destroy the river_status_manager object
//
// This request indicates that the client will not use the
// river_status_manager object any more. Objects that have been created
// through this instance are not affected.
func (i *StatusManager) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// GetRiverOutputStatus : create an output status object
//
// This creates a new river_output_status object for the given wl_output.
func (i *StatusManager) GetRiverOutputStatus(output *client.Output) (*OutputStatus, error) {
	id := NewOutputStatus(i.Context())
	const opcode = 1
	const _reqBufLen = 8 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], output.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return id, err
}

// GetRiverSeatStatus : create a seat status object
//
// This creates a new river_seat_status object for the given wl_seat.
func (i *StatusManager) GetRiverSeatStatus(seat *client.Seat) (*SeatStatus, error) {
	id := NewSeatStatus(i.Context())
	const opcode = 2
	const _reqBufLen = 8 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], id.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], seat.ID())
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return id, err
}

// OutputStatus : track output tags and focus
//
// This interface allows clients to receive information about the current
// windowing state of an output.
type OutputStatus struct {
	client.BaseProxy
	focusedTagsHandler     OutputStatusFocusedTagsHandlerFunc
	viewTagsHandler        OutputStatusViewTagsHandlerFunc
	urgentTagsHandler      OutputStatusUrgentTagsHandlerFunc
	layoutNameHandler      OutputStatusLayoutNameHandlerFunc
	layoutNameClearHandler OutputStatusLayoutNameClearHandlerFunc
}

// NewOutputStatus : track output tags and focus
//
// This interface allows clients to receive information about the current
// windowing state of an output.
func NewOutputStatus(ctx *client.Context) *OutputStatus {
	zriverOutputStatusV1 := &OutputStatus{}
	ctx.Register(zriverOutputStatusV1)
	return zriverOutputStatusV1
}

// Destroy : destroy the river_output_status object
//
// This request indicates that the client will not use the
// river_output_status object any more.
func (i *OutputStatus) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// OutputStatusFocusedTagsEvent : focused tags of the output
//
// Sent once binding the interface and again whenever the tag focus of
// the output changes.
type OutputStatusFocusedTagsEvent struct {
	Tags uint32
}
type OutputStatusFocusedTagsHandlerFunc func(OutputStatusFocusedTagsEvent)

// SetFocusedTagsHandler : sets handler for OutputStatusFocusedTagsEvent
func (i *OutputStatus) SetFocusedTagsHandler(f OutputStatusFocusedTagsHandlerFunc) {
	i.focusedTagsHandler = f
}

// OutputStatusViewTagsEvent : tag state of an output's views
//
// Sent once on binding the interface and again whenever the tag state
// of the output changes.
type OutputStatusViewTagsEvent struct {
	Tags []byte
}
type OutputStatusViewTagsHandlerFunc func(OutputStatusViewTagsEvent)

// SetViewTagsHandler : sets handler for OutputStatusViewTagsEvent
func (i *OutputStatus) SetViewTagsHandler(f OutputStatusViewTagsHandlerFunc) {
	i.viewTagsHandler = f
}

// OutputStatusUrgentTagsEvent : tags of the output with an urgent view
//
// Sent once on binding the interface and again whenever the set of
// tags with at least one urgent view changes.
type OutputStatusUrgentTagsEvent struct {
	Tags uint32
}
type OutputStatusUrgentTagsHandlerFunc func(OutputStatusUrgentTagsEvent)

// SetUrgentTagsHandler : sets handler for OutputStatusUrgentTagsEvent
func (i *OutputStatus) SetUrgentTagsHandler(f OutputStatusUrgentTagsHandlerFunc) {
	i.urgentTagsHandler = f
}

// OutputStatusLayoutNameEvent : name of the layout
//
// Sent once on binding the interface should a layout name exist and again
// whenever the name changes.
type OutputStatusLayoutNameEvent struct {
	Name string
}
type OutputStatusLayoutNameHandlerFunc func(OutputStatusLayoutNameEvent)

// SetLayoutNameHandler : sets handler for OutputStatusLayoutNameEvent
func (i *OutputStatus) SetLayoutNameHandler(f OutputStatusLayoutNameHandlerFunc) {
	i.layoutNameHandler = f
}

// OutputStatusLayoutNameClearEvent : name of the layout
//
// Sent when the current layout name has been removed without a new one
// being set, for example when the active layout generator disconnects.
type OutputStatusLayoutNameClearEvent struct{}
type OutputStatusLayoutNameClearHandlerFunc func(OutputStatusLayoutNameClearEvent)

// SetLayoutNameClearHandler : sets handler for OutputStatusLayoutNameClearEvent
func (i *OutputStatus) SetLayoutNameClearHandler(f OutputStatusLayoutNameClearHandlerFunc) {
	i.layoutNameClearHandler = f
}

func (i *OutputStatus) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.focusedTagsHandler == nil {
			return
		}
		var e OutputStatusFocusedTagsEvent
		l := 0
		e.Tags = client.Uint32(data[l : l+4])
		l += 4

		i.focusedTagsHandler(e)
	case 1:
		if i.viewTagsHandler == nil {
			return
		}
		var e OutputStatusViewTagsEvent
		l := 0
		tagsLen := int(client.Uint32(data[l : l+4]))
		l += 4
		e.Tags = make([]byte, tagsLen)
		copy(e.Tags, data[l:l+tagsLen])
		l += tagsLen

		i.viewTagsHandler(e)
	case 2:
		if i.urgentTagsHandler == nil {
			return
		}
		var e OutputStatusUrgentTagsEvent
		l := 0
		e.Tags = client.Uint32(data[l : l+4])
		l += 4

		i.urgentTagsHandler(e)
	case 3:
		if i.layoutNameHandler == nil {
			return
		}
		var e OutputStatusLayoutNameEvent
		l := 0
		nameLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Name = client.String(data[l : l+nameLen])
		l += nameLen

		i.layoutNameHandler(e)
	case 4:
		if i.layoutNameClearHandler == nil {
			return
		}
		var e OutputStatusLayoutNameClearEvent

		i.layoutNameClearHandler(e)
	}
}

// SeatStatus : track seat focus
//
// This interface allows clients to receive information about the current
// focus of a seat. Note that (un)focused_output events will only be sent
// if the client has bound the relevant wl_output globals.
type SeatStatus struct {
	client.BaseProxy
	focusedOutputHandler   SeatStatusFocusedOutputHandlerFunc
	unfocusedOutputHandler SeatStatusUnfocusedOutputHandlerFunc
	focusedViewHandler     SeatStatusFocusedViewHandlerFunc
	modeHandler            SeatStatusModeHandlerFunc
}

// NewSeatStatus : track seat focus
//
// This interface allows clients to receive information about the current
// focus of a seat. Note that (un)focused_output events will only be sent
// if the client has bound the relevant wl_output globals.
func NewSeatStatus(ctx *client.Context) *SeatStatus {
	zriverSeatStatusV1 := &SeatStatus{}
	ctx.Register(zriverSeatStatusV1)
	return zriverSeatStatusV1
}

// Destroy : destroy the river_seat_status object
//
// This request indicates that the client will not use the
// river_seat_status object any more.
func (i *SeatStatus) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SeatStatusFocusedOutputEvent : the seat focused an output
//
// Sent on binding the interface and again whenever an output gains focus.
type SeatStatusFocusedOutputEvent struct {
	Output *client.Output
}
type SeatStatusFocusedOutputHandlerFunc func(SeatStatusFocusedOutputEvent)

// SetFocusedOutputHandler : sets handler for SeatStatusFocusedOutputEvent
func (i *SeatStatus) SetFocusedOutputHandler(f SeatStatusFocusedOutputHandlerFunc) {
	i.focusedOutputHandler = f
}

// SeatStatusUnfocusedOutputEvent : the seat unfocused an output
//
// Sent whenever an output loses focus.
type SeatStatusUnfocusedOutputEvent struct {
	Output *client.Output
}
type SeatStatusUnfocusedOutputHandlerFunc func(SeatStatusUnfocusedOutputEvent)

// SetUnfocusedOutputHandler : sets handler for SeatStatusUnfocusedOutputEvent
func (i *SeatStatus) SetUnfocusedOutputHandler(f SeatStatusUnfocusedOutputHandlerFunc) {
	i.unfocusedOutputHandler = f
}

// SeatStatusFocusedViewEvent : information on the focused view
//
// Sent once on binding the interface and again whenever the focused
// view or a property thereof changes. The title may be an empty string
// if no view is focused or the focused view did not set a title.
type SeatStatusFocusedViewEvent struct {
	Title string
}
type SeatStatusFocusedViewHandlerFunc func(SeatStatusFocusedViewEvent)

// SetFocusedViewHandler : sets handler for SeatStatusFocusedViewEvent
func (i *SeatStatus) SetFocusedViewHandler(f SeatStatusFocusedViewHandlerFunc) {
	i.focusedViewHandler = f
}

// SeatStatusModeEvent : the active mode changed
//
// Sent once on binding the interface and again whenever a new mode
// is entered (e.g. with riverctl enter-mode foobar).
type SeatStatusModeEvent struct {
	Name string
}
type SeatStatusModeHandlerFunc func(SeatStatusModeEvent)

// SetModeHandler : sets handler for SeatStatusModeEvent
func (i *SeatStatus) SetModeHandler(f SeatStatusModeHandlerFunc) {
	i.modeHandler = f
}

func (i *SeatStatus) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.focusedOutputHandler == nil {
			return
		}
		var e SeatStatusFocusedOutputEvent
		l := 0
		e.Output = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Output)
		l += 4

		i.focusedOutputHandler(e)
	case 1:
		if i.unfocusedOutputHandler == nil {
			return
		}
		var e SeatStatusUnfocusedOutputEvent
		l := 0
		e.Output = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Output)
		l += 4

		i.unfocusedOutputHandler(e)
	case 2:
		if i.focusedViewHandler == nil {
			return
		}
		var e SeatStatusFocusedViewEvent
		l := 0
		titleLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Title = client.String(data[l : l+titleLen])
		l += titleLen

		i.focusedViewHandler(e)
	case 3:
		if i.modeHandler == nil {
			return
		}
		var e SeatStatusModeEvent
		l := 0
		nameLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Name = client.String(data[l : l+nameLen])
		l += nameLen

		i.modeHandler(e)
	}
}
